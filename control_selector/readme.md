## Практическое задание №4  
### Создание алгоритмов управления движением робота в виде иерархии классов с общим интерфейсом  

(команды выполняются при нахождении в директории рабочего пространства)  
0. Скачиваем проект:
```bash
git clone <адрес репозитария> src
```
или обновляем исходные файлы(если проект уже скачан):
```bash
cd src  
git pull  
cd ..  
```
В папке `src` должен появиться проект `control_selector`
1. Сборка проекта (из рабочей директории):
```bash
catkin_make
```
2. Не забываем в каждом терминале, где планируем запускать бинарные файлы проекта, инициализировать рабочее пространство:  
```bash
source devel/setup.bash
```
3. Запуск модели робота и управляющего кода:  
```bash
roslaunch control_selector selector.launch
```
Должно открыться окно симулятора Stage с роботом в мире с препятствиями. Параллельно запускается управляющий код. Робот после запуска начинает движение по алгоритму жука (по прямой до препятствия, а затем разворот до исчезновения препятствия)  

4. В тексте программы логика управления роботом отделена от кода взаимодействия с ROS. Взаимодействие с ROS (обработка таймера и сообщений) реализовано в файле `control_selector_node.cpp`, а алгоритм управления реализован в виде класса `Voyager`(Voyager.h, Voyager.cpp), являющегося наследником класса `Control` (control.h). Класс Control задает интерфейс работы с системой управления. В данном случае это три функции: установки данных дальномера (setLaserData), установка позиции робота (setRobotPose) и получение управления (getControl). Можно реализовать и другие алгоритмы управления как наследники класса Control и переключаться между ними по команде пользователя. В программе уже реализован ещё один алгоритм Dummy, а также механизм переключения между алгоритмами. Программа обрабатывает получение сообщения с номером алгоритма по топику `/selector` в функции selectCallback и устанавливает указатель controlPtr на выбранный алгоритм из созданных. Благодаря тому, что все алгоритмы наследуют от общего предка их указатели можно хранить в одном массиве, как указатели на базовый класс, а благодоря тому, что функции класса `Control` объявлены как виртуальные, при вызове остальных колбеков - по указателю будут вызываться функции выбранного алгоритма. 
5. Попробуем перключить алгоритм, отправив сообщение с помощью утилиты rostopic
```bash
rostopic pub /selector std_msgs/UInt16 <номер алгоритма в массиве>
```
Наблюдаем, что робот продолжает движение по выбранному алгоритму или останавливается если номер выше, чем количество доступных алгоритмов (элементов массива controls)   

## Задача
1. Реализовать алгоритм движения вдоль стены как еще один наследник класса Contol и встроить его в приложение
2. Реализовать клиент (консольный) для переключения алгоритмов.  
